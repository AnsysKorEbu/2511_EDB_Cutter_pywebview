"""
FPCB-Extractor Integration Module

This module provides integration between the FPCB-Extractor package
and the EDB Cutter application for advanced stackup processing.
"""
import json
from pathlib import Path
from typing import Dict, List, Optional, Tuple

from util.logger_module import logger


def process_stackup_with_extractor(excel_file: str, output_dir: Optional[str] = None, merge_copper: bool = True) -> Tuple[bool, Dict]:
    """
    Process stackup Excel file using FPCB-Extractor.

    Args:
        excel_file: Path to input Excel file
        output_dir: Optional output directory (defaults to stackup_new/)
        merge_copper: Whether to merge consecutive copper layers

    Returns:
        Tuple of (success, result_dict) where result_dict contains:
            - output_file: Path to generated JSON file
            - format_type: Detected format type (type0-type4)
            - layer_count: Number of layers extracted
            - section_count: Number of sections found
            - sections: List of section names
            - layer_data: Full layer data
            - section_data: Full section data
    """
    try:
        from stackup_extractor import process_stackup

        logger.info(f"\n{'=' * 70}")
        logger.info("Processing stackup with FPCB-Extractor")
        logger.info(f"Excel file: {excel_file}")
        logger.info(f"Merge copper: {merge_copper}")
        logger.info(f"{'=' * 70}")

        # Set output directory
        if output_dir is None:
            output_dir = Path('stackup_new')
            output_dir.mkdir(exist_ok=True)
        else:
            output_dir = Path(output_dir)
            output_dir.mkdir(parents=True, exist_ok=True)

        # Generate output JSON filename
        excel_path = Path(excel_file)
        output_json = output_dir / f"{excel_path.stem}_extracted.json"

        # Process with stackup_extractor
        logger.info(f"Running stackup_extractor...")
        output_path = process_stackup(
            excel_file,
            str(output_json),
            merge_copper=merge_copper
        )

        logger.info(f"✓ Extraction completed: {output_path}")

        # Load the generated JSON to extract metadata
        with open(output_path, 'r', encoding='utf-8') as f:
            extracted_data = json.load(f)

        # Extract sections from section_data
        section_data = extracted_data.get('section_data', {})
        sections = []

        for section_id, section_info in section_data.items():
            section_name = section_info.get('name', section_id)
            if section_name not in sections:
                sections.append(section_name)

        # Build result dictionary
        result = {
            'output_file': str(output_path),
            'format_type': extracted_data.get('format_type', 'unknown'),
            'layer_count': len(extracted_data.get('layer_data', [])),
            'section_count': len(section_data),
            'sections': sections,
            'layer_data': extracted_data.get('layer_data', []),
            'section_data': section_data,
            'summary': extracted_data.get('summary', {})
        }

        logger.info(f"✓ Processing completed successfully:")
        logger.info(f"  - Format: {result['format_type']}")
        logger.info(f"  - Layers: {result['layer_count']}")
        logger.info(f"  - Sections: {result['section_count']}")
        logger.info(f"  - Output: {output_path}")
        logger.info(f"{'=' * 70}\n")

        return True, result

    except ImportError as e:
        error_msg = f"FPCB-Extractor package not found. Please install it first: {e}"
        logger.error(error_msg)
        return False, {'error': error_msg}

    except Exception as e:
        error_msg = f"Failed to process stackup with extractor: {str(e)}"
        logger.error(error_msg)
        import traceback
        traceback.print_exc()
        return False, {'error': error_msg}


def extract_sections_from_json(json_file: str) -> List[str]:
    """
    Extract section names from FPCB-Extractor JSON output.

    Args:
        json_file: Path to JSON file generated by stackup_extractor

    Returns:
        List of section names
    """
    try:
        with open(json_file, 'r', encoding='utf-8') as f:
            data = json.load(f)

        section_data = data.get('section_data', {})
        sections = []

        for section_id, section_info in section_data.items():
            section_name = section_info.get('name', section_id)
            if section_name not in sections:
                sections.append(section_name)

        return sections

    except Exception as e:
        logger.error(f"Failed to extract sections from JSON: {e}")
        return []


def get_layer_data_for_section(json_file: str, section_name: str) -> List[Dict]:
    """
    Get layer data for a specific section from FPCB-Extractor JSON.

    Args:
        json_file: Path to JSON file generated by stackup_extractor
        section_name: Name of the section to extract

    Returns:
        List of layer dictionaries for the section
    """
    try:
        with open(json_file, 'r', encoding='utf-8') as f:
            data = json.load(f)

        section_data = data.get('section_data', {})

        # Find matching section
        for section_id, section_info in section_data.items():
            if section_info.get('name') == section_name:
                return section_info.get('layers', [])

        logger.warning(f"Section '{section_name}' not found in JSON")
        return []

    except Exception as e:
        logger.error(f"Failed to get layer data for section: {e}")
        return []


def get_edb_conductor_layer_count(edb_data: Dict) -> int:
    """
    Get conductor layer count from already-loaded EDB data.

    Collects unique layer names from planes, traces, vias
    (same as layersMap in canvas.js).
    """
    layers = set()

    for plane in edb_data.get('planes', []) or []:
        layer = plane.get('layer')
        if layer:
            layers.add(layer)

    for trace in edb_data.get('traces', []) or []:
        layer = trace.get('layer')
        if layer:
            layers.add(layer)

    for via in edb_data.get('vias', []) or []:
        for layer_name in via.get('layer_range_names', []) or []:
            if layer_name:
                layers.add(layer_name)

    return len(layers)


def get_sss_copper_count_per_section(layer_sss_path: str) -> Dict:
    """
    Count COPPER layers per cut/section from SSS layer file.

    Args:
        layer_sss_path: Path to the _layers_*.sss file

    Returns:
        Dict with per-cut results:
        {
            'cut_001': {'section': 'Section A', 'copper_count': 4},
            ...
        }
    """
    with open(layer_sss_path, 'r', encoding='utf-8') as f:
        sss_data = json.load(f)

    cut_layer_data = sss_data.get('cut_layer_data', {})
    results = {}

    for cut_id, cut_info in cut_layer_data.items():
        section_name = cut_info.get('section', cut_id)
        layers = cut_info.get('layers', [])
        copper_count = sum(
            1 for layer in layers
            if layer.get('spec_name', '').upper() == 'COPPER'
        )
        results[cut_id] = {
            'section': section_name,
            'copper_count': copper_count,
        }

    return results


def validate_layer_count_from_sss(edb_data: Dict, layer_sss_path: str) -> List[Dict]:
    """
    Validate EDB conductor layer count against each section's COPPER count in SSS.

    Args:
        edb_data: self.data dict from GUI (planes/traces/vias)
        layer_sss_path: Path to _layers_*.sss file

    Returns:
        List of per-section validation results:
        [
            {
                'cut_id': 'cut_001',
                'section': 'Section A',
                'copper_count': 4,
                'edb_count': 4,
                'match': True
            },
            ...
        ]
    """
    edb_count = get_edb_conductor_layer_count(edb_data)
    section_counts = get_sss_copper_count_per_section(layer_sss_path)

    results = []
    for cut_id, info in section_counts.items():
        match = (info['copper_count'] == edb_count)
        results.append({
            'cut_id': cut_id,
            'section': info['section'],
            'copper_count': info['copper_count'],
            'edb_count': edb_count,
            'match': match,
        })

        status = "OK" if match else "FAIL"
        logger.info(
            f"  [{status}] {cut_id} ({info['section']}): "
            f"SSS COPPER={info['copper_count']}, EDB conductor={edb_count}"
        )

    return results
