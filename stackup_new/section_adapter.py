"""
Section Adapter for FPCB-Extractor

Adapts stackup_extractor JSON output to the format expected by
the legacy section selector system.
"""
import json
from pathlib import Path
from typing import Dict, List, Tuple
from datetime import datetime

from util.logger_module import logger


class ExtractorSectionAdapter:
    """
    Adapter to convert FPCB-Extractor JSON output to section selector format.

    This allows seamless integration with the existing SectionSelector class
    without modifying its internal logic.
    """

    def __init__(self, extractor_json_path: str):
        """
        Initialize adapter with FPCB-Extractor JSON output.

        Args:
            extractor_json_path: Path to JSON file generated by stackup_extractor
        """
        self.json_path = extractor_json_path
        self._data = None
        self._load_data()

    def _load_data(self):
        """Load and parse the extractor JSON file."""
        try:
            with open(self.json_path, 'r', encoding='utf-8') as f:
                self._data = json.load(f)
            logger.info(f"Loaded extractor data from {self.json_path}")
        except Exception as e:
            logger.error(f"Failed to load extractor JSON: {e}")
            raise

    def get_sections(self) -> List[str]:
        """
        Extract section names from extractor data.

        Returns:
            List of section name strings
        """
        section_data = self._data.get('section_data', {})
        sections = []

        for section_id, section_info in section_data.items():
            section_name = section_info.get('name', section_id)
            if section_name not in sections:
                sections.append(section_name)

        return sections

    def get_layer_data_for_section(self, section_name: str) -> List[Dict]:
        """
        Get layer data for a specific section in SectionSelector format.

        Args:
            section_name: Name of the section

        Returns:
            List of layer dictionaries with format:
            [
                {
                    'width': float (thickness in um),
                    'material': str ('copper' or 'air'),
                    'spec_name': str (original material name)
                }
            ]
        """
        section_data = self._data.get('section_data', {})

        # Find matching section
        for section_id, section_info in section_data.items():
            if section_info.get('name') == section_name:
                return self._convert_layers_to_selector_format(
                    section_info.get('layers', [])
                )

        logger.warning(f"Section '{section_name}' not found in extractor data")
        return []

    def _convert_layers_to_selector_format(self, layers: List[Dict]) -> List[Dict]:
        """
        Convert FPCB-Extractor layer format to SectionSelector format.

        Extractor format:
        {
            'layer': 1,
            'material': 'COPPER',
            'thickness': 35,
            'Dk': 3.0,
            'Df': 0.02
        }

        SectionSelector format:
        {
            'width': 35.0,
            'material': 'copper',
            'spec_name': 'COPPER'
        }

        Args:
            layers: List of layer dicts from extractor

        Returns:
            List of layer dicts in selector format
        """
        converted = []

        for layer in layers:
            material_name = layer.get('material', 'UNKNOWN')
            thickness = layer.get('thickness', 0)

            # Map material name to 'copper' or 'air'
            material_type = self._map_material_to_type(material_name)

            converted.append({
                'width': float(thickness),
                'material': material_type,
                'spec_name': material_name
            })

        return converted

    def _map_material_to_type(self, material_name: str) -> str:
        """
        Map material name to 'copper' or 'air'.

        Args:
            material_name: Material name from extractor

        Returns:
            'copper' or 'air'
        """
        material_lower = material_name.lower()

        # Air/space materials
        air_keywords = ['air', 'space', 'gap', 'void']
        for keyword in air_keywords:
            if keyword in material_lower:
                return 'air'

        # Default to copper for conductive materials
        return 'copper'

    def save_section_mapping_sss(
        self,
        cut_section_map: Dict[str, str],
        output_path: str,
        original_excel_file: str = None
    ):
        """
        Save cut-section mapping to .sss file (compatible with SectionSelector format).

        Args:
            cut_section_map: Mapping of cut IDs to section names
                Example: {'cut_001': 'RIGID 5', 'cut_002': 'C/N 1'}
            output_path: Path to save .sss file
            original_excel_file: Original Excel file path (optional)
        """
        if not cut_section_map:
            raise ValueError("cut_section_map cannot be empty")

        sections = self.get_sections()

        # Build .sss file structure (compatible with SectionSelector)
        sss_data = {
            "excel_file": original_excel_file or str(Path(self.json_path).as_posix()),
            "extractor_json": str(Path(self.json_path).as_posix()),
            "cut_section_mapping": cut_section_map,
            "available_sections": sections,
            "version": "2.0",  # Version 2.0 indicates extractor-based
            "source": "fpcb_extractor",
            "format_type": self._data.get('format_type', 'unknown'),
            "timestamp": datetime.now().isoformat()
        }

        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(sss_data, f, indent=2, ensure_ascii=False)
            logger.info(f"Saved section mapping SSS: {output_path}")
        except IOError as e:
            raise IOError(f"Failed to write .sss file: {str(e)}")

    def save_layer_data_sss(
        self,
        cut_section_map: Dict[str, str],
        output_path: str,
        original_excel_file: str = None
    ):
        """
        Save layer data for selected sections to .sss file.

        Args:
            cut_section_map: Mapping of cut IDs to section names
            output_path: Path to save layer .sss file
            original_excel_file: Original Excel file path (optional)
        """
        if not cut_section_map:
            raise ValueError("cut_section_map cannot be empty")

        # Extract layer data for each selected section
        layer_data_by_cut = {}

        for cut_id, section_name in cut_section_map.items():
            try:
                layer_data = self.get_layer_data_for_section(section_name)
                layer_data_by_cut[cut_id] = {
                    'section': section_name,
                    'layers': layer_data
                }
            except Exception as e:
                logger.error(f"Failed to get layer data for {cut_id}: {e}")
                layer_data_by_cut[cut_id] = {
                    'section': section_name,
                    'layers': [],
                    'error': str(e)
                }

        # Build layer .sss file structure
        layer_sss_data = {
            "excel_file": original_excel_file or str(Path(self.json_path).as_posix()),
            "extractor_json": str(Path(self.json_path).as_posix()),
            "cut_layer_data": layer_data_by_cut,
            "version": "2.0",
            "source": "fpcb_extractor",
            "format_type": self._data.get('format_type', 'unknown'),
            "timestamp": datetime.now().isoformat()
        }

        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(layer_sss_data, f, indent=2, ensure_ascii=False)
            logger.info(f"Saved layer data SSS: {output_path}")
        except IOError as e:
            raise IOError(f"Failed to write layer .sss file: {str(e)}")

    def validate_mapping(self, cut_section_map: Dict[str, str]) -> Tuple[bool, List[str]]:
        """
        Validate cut-section mapping.

        Args:
            cut_section_map: Mapping to validate

        Returns:
            Tuple of (is_valid, error_messages)
        """
        errors = []

        if not cut_section_map:
            errors.append("Mapping is empty")
            return (False, errors)

        sections = self.get_sections()

        # Validate each cut's section
        for cut_id, selected_section in cut_section_map.items():
            if not selected_section:
                errors.append(f"Cut '{cut_id}' has no section selected")
                continue

            if selected_section not in sections:
                errors.append(f"Invalid section '{selected_section}' for cut '{cut_id}'")

        is_valid = len(errors) == 0
        return (is_valid, errors)
