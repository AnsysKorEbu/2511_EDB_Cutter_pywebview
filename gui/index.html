<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EDB 2D Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1e1e1e;
            color: #ffffff;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 300px;
            background: #252526;
            border-right: 1px solid #3e3e42;
            padding: 20px;
            overflow-y: auto;
        }

        .main-view {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            background: #252526;
            border-bottom: 1px solid #3e3e42;
            padding: 15px 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #1e1e1e;
        }

        canvas {
            display: block;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #cccccc;
        }

        .info-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #1e1e1e;
            border-radius: 4px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 13px;
        }

        .info-label {
            color: #9cdcfe;
        }

        .info-value {
            color: #dcdcaa;
            font-weight: 600;
        }

        .layer-list {
            margin-top: 10px;
        }

        .layer-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background: #1e1e1e;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .layer-item:hover {
            background: #2d2d30;
        }

        .layer-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 10px;
            border: 1px solid #3e3e42;
        }

        .layer-info {
            flex: 1;
            display: flex;
            justify-content: space-between;
            font-size: 13px;
        }

        .layer-name {
            color: #cccccc;
        }

        .layer-count {
            color: #858585;
        }

        button {
            padding: 8px 16px;
            background: #0e639c;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: background 0.2s;
        }

        button:hover {
            background: #1177bb;
        }

        button:active {
            background: #0d5a8f;
        }

        button:disabled {
            background: #3e3e42;
            cursor: not-allowed;
        }

        .status-bar {
            background: #252526;
            border-top: 1px solid #3e3e42;
            padding: 5px 20px;
            font-size: 12px;
            color: #858585;
            display: flex;
            gap: 20px;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .control-label {
            font-size: 12px;
            color: #858585;
        }

        .zoom-controls {
            display: flex;
            gap: 5px;
        }

        .icon-btn {
            padding: 6px 10px;
            background: #333333;
            min-width: auto;
        }

        .icon-btn:hover {
            background: #3e3e42;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .spinner {
            border: 3px solid #3e3e42;
            border-top: 3px solid #0e639c;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        .btn-reload {
            background: #0e639c;
        }

        .btn-reload:hover {
            background: #1177bb;
        }

        /* Cut Mode Styles */
        .btn-cut-mode {
            background: #3e3e42;
            margin-top: 10px;
        }

        .btn-cut-mode.active {
            background: #ff6b35;
        }

        .btn-cut-mode.active:hover {
            background: #ff8555;
        }

        .cut-tools {
            margin-top: 15px;
            padding: 15px;
            background: #1e1e1e;
            border-radius: 4px;
        }

        .cut-tool-btn {
            width: 100%;
            margin: 5px 0;
            padding: 10px;
            background: #3e3e42;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .cut-tool-btn.active {
            background: #0e639c;
        }

        .cut-tool-btn:hover {
            background: #4e4e52;
        }

        .cut-tool-btn.active:hover {
            background: #1177bb;
        }

        .cut-list {
            margin-top: 15px;
            padding: 15px;
            background: #1e1e1e;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
        }

        .cut-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background: #252526;
            border-radius: 4px;
            font-size: 12px;
        }

        .cut-list-item:hover {
            background: #2d2d30;
        }

        .cut-delete-btn {
            padding: 4px 8px;
            background: #c72b2b;
            font-size: 11px;
            min-width: auto;
        }

        .cut-delete-btn:hover {
            background: #e03e3e;
        }

        .cut-actions {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }

        .cut-actions button {
            flex: 1;
            font-size: 11px;
            padding: 6px;
        }

        canvas.cut-mode {
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h2>EDB 2D Viewer</h2>

            <div class="info-section">
                <h3 style="font-size: 14px; margin-bottom: 10px; color: #9cdcfe;">Data Information</h3>
                <div class="info-item">
                    <span class="info-label">Planes:</span>
                    <span class="info-value" id="planeCount">0</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Layers:</span>
                    <span class="info-value" id="layerCount">0</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Total Points:</span>
                    <span class="info-value" id="pointCount">0</span>
                </div>
            </div>

            <div class="info-section">
                <h3 style="font-size: 14px; margin-bottom: 10px; color: #9cdcfe;">Layers</h3>
                <div class="layer-list" id="layerList">
                    <div style="color: #858585; font-size: 12px; text-align: center; padding: 20px;">
                        Click "Reload Data" to load
                    </div>
                </div>
            </div>

            <button class="btn-reload" onclick="reloadData()" id="reloadBtn">Reload Data</button>

            <button class="btn-cut-mode" onclick="toggleCutMode()" id="cutModeBtn">‚úÇÔ∏è Cut Mode</button>

            <div id="cutTools" class="cut-tools hidden">
                <h3 style="font-size: 14px; margin-bottom: 10px; color: #9cdcfe;">Cut Tools</h3>
                <button class="cut-tool-btn" onclick="selectCutTool('line')" data-tool="line">
                    <span>üìè</span> Line Cut
                </button>
                <button class="cut-tool-btn" onclick="selectCutTool('rectangle')" data-tool="rectangle">
                    <span>‚ñ≠</span> Rectangle
                </button>
                <button class="cut-tool-btn" onclick="selectCutTool('polyline')" data-tool="polyline">
                    <span>üìê</span> Polyline
                </button>
                <div style="margin-top: 10px; padding: 8px; background: #252526; border-radius: 4px; font-size: 11px; color: #858585;">
                    <div id="cutHint">Select a tool to start</div>
                </div>
                <button id="finishCutBtn" class="hidden" onclick="finishCurrentCut()" style="margin-top: 10px; background: #10a37f; width: 100%;">
                    ‚úì Finish & Save Cut
                </button>
                <button id="panModeBtn" onclick="togglePanMode()" style="margin-top: 10px; background: #3e3e42; width: 100%;">
                    ü§ö Pan Mode (Space)
                </button>
            </div>

            <div id="cutList" class="cut-list hidden">
                <h3 style="font-size: 14px; margin-bottom: 10px; color: #9cdcfe;">Saved Cuts (<span id="cutCount">0</span>)</h3>
                <div id="cutListItems">
                    <div style="color: #858585; font-size: 11px; text-align: center;">No cuts saved</div>
                </div>
                <div class="cut-actions">
                    <button onclick="refreshCutList()">Refresh</button>
                    <button onclick="clearAllCuts()">Clear All</button>
                </div>
            </div>
        </div>

        <div class="main-view">
            <div class="toolbar">
                <button onclick="resetView()">Reset View</button>
                <div class="zoom-controls">
                    <button class="icon-btn" onclick="zoomIn()">+</button>
                    <button class="icon-btn" onclick="zoomOut()">-</button>
                </div>
                <div class="controls">
                    <span class="control-label">Zoom:</span>
                    <span id="zoomLevel">100%</span>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="canvas"></canvas>
                <div class="loading hidden" id="loading">
                    <div class="spinner"></div>
                    <div>Loading data...</div>
                </div>
            </div>

            <div class="status-bar">
                <span id="statusText">Ready - Click "Reload Data" to load planes from source folder</span>
                <span id="mousePos">X: 0.000, Y: 0.000</span>
            </div>
        </div>
    </div>

    <script>
        // Canvas and context
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Data storage
        let planesData = [];
        let layersMap = new Map();

        // View state
        let viewState = {
            offsetX: 0,
            offsetY: 0,
            scale: 100,
            isDragging: false,
            lastX: 0,
            lastY: 0
        };

        // Bounds
        let dataBounds = {
            minX: Infinity,
            minY: Infinity,
            maxX: -Infinity,
            maxY: -Infinity
        };

        // Layer colors
        const layerColors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
            '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B739', '#52B788'
        ];

        // Cut mode state
        let cutMode = {
            enabled: false,
            activeTool: null,
            currentCut: [],
            isDrawing: false,
            savedCuts: [],
            panMode: false  // Temporary pan mode in cut mode
        };

        // Initialize canvas size
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            render();
        }

        // Reload data from Python API
        async function reloadData() {
            const loading = document.getElementById('loading');
            const statusText = document.getElementById('statusText');
            const reloadBtn = document.getElementById('reloadBtn');

            loading.classList.remove('hidden');
            statusText.textContent = 'Loading data from source folder...';
            reloadBtn.disabled = true;

            try {
                if (!window.pywebview) {
                    throw new Error('PyWebView API not available');
                }

                // Get planes data from Python
                const data = await window.pywebview.api.get_planes_data();

                if (data.length === 0) {
                    throw new Error('No planes data found in source folder');
                }

                loadData(data);
                statusText.textContent = `Loaded ${data.length} planes successfully`;
            } catch (error) {
                console.error('Error loading data:', error);
                statusText.textContent = 'Error: ' + error.message;
                alert('Error loading data: ' + error.message);
            } finally {
                loading.classList.add('hidden');
                reloadBtn.disabled = false;
            }
        }

        // Load data and process
        function loadData(data) {
            planesData = data;
            layersMap.clear();

            // Calculate bounds and group by layer
            dataBounds = {
                minX: Infinity,
                minY: Infinity,
                maxX: -Infinity,
                maxY: -Infinity
            };

            let totalPoints = 0;

            planesData.forEach(plane => {
                // Update bounds from points
                if (plane.points && plane.points.length > 0) {
                    plane.points.forEach(([x, y]) => {
                        dataBounds.minX = Math.min(dataBounds.minX, x);
                        dataBounds.minY = Math.min(dataBounds.minY, y);
                        dataBounds.maxX = Math.max(dataBounds.maxX, x);
                        dataBounds.maxY = Math.max(dataBounds.maxY, y);
                    });
                }

                // Count points
                totalPoints += plane.points.length;

                // Group by layer
                const layer = plane.layer || 'default';
                if (!layersMap.has(layer)) {
                    layersMap.set(layer, {
                        name: layer,
                        planes: [],
                        visible: true,
                        color: layerColors[layersMap.size % layerColors.length]
                    });
                }
                layersMap.get(layer).planes.push(plane);
            });

            // Update UI
            document.getElementById('planeCount').textContent = planesData.length;
            document.getElementById('layerCount').textContent = layersMap.size;
            document.getElementById('pointCount').textContent = totalPoints.toLocaleString();

            updateLayerList();
            resetView();
        }

        // Update layer list UI
        function updateLayerList() {
            const layerList = document.getElementById('layerList');
            layerList.innerHTML = '';

            layersMap.forEach((layer, layerName) => {
                const item = document.createElement('div');
                item.className = 'layer-item';
                item.style.opacity = layer.visible ? '1' : '0.5';
                item.onclick = () => toggleLayer(layerName);

                item.innerHTML = `
                    <div class="layer-color" style="background: ${layer.color}"></div>
                    <div class="layer-info">
                        <span class="layer-name">${layerName}</span>
                        <span class="layer-count">${layer.planes.length}</span>
                    </div>
                `;

                layerList.appendChild(item);
            });
        }

        // Toggle layer visibility
        function toggleLayer(layerName) {
            const layer = layersMap.get(layerName);
            if (layer) {
                layer.visible = !layer.visible;
                updateLayerList();
                render();
            }
        }

        // Reset view to fit all data
        function resetView() {
            if (planesData.length === 0) return;

            const dataWidth = dataBounds.maxX - dataBounds.minX;
            const dataHeight = dataBounds.maxY - dataBounds.minY;

            // Calculate scale to fit
            const scaleX = (canvas.width * 0.8) / dataWidth;
            const scaleY = (canvas.height * 0.8) / dataHeight;
            viewState.scale = Math.min(scaleX, scaleY);

            // Center the view
            const centerX = (dataBounds.minX + dataBounds.maxX) / 2;
            const centerY = (dataBounds.minY + dataBounds.maxY) / 2;

            viewState.offsetX = canvas.width / 2 - centerX * viewState.scale;
            viewState.offsetY = canvas.height / 2 - centerY * viewState.scale;

            updateZoomLabel();
            render();
        }

        // World to screen coordinates
        function worldToScreen(x, y) {
            return {
                x: x * viewState.scale + viewState.offsetX,
                y: y * viewState.scale + viewState.offsetY
            };
        }

        // Screen to world coordinates
        function screenToWorld(x, y) {
            return {
                x: (x - viewState.offsetX) / viewState.scale,
                y: (y - viewState.offsetY) / viewState.scale
            };
        }

        // Render all planes
        function render() {
            // Clear canvas
            ctx.fillStyle = '#1e1e1e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (planesData.length === 0) {
                ctx.fillStyle = '#858585';
                ctx.font = '14px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('Click "Reload Data" to load planes from source folder', canvas.width / 2, canvas.height / 2);
                return;
            }

            // Draw grid
            drawGrid();

            // Draw each layer
            layersMap.forEach((layer) => {
                if (!layer.visible) return;

                ctx.fillStyle = layer.color + '80'; // Add transparency
                ctx.strokeStyle = layer.color;
                ctx.lineWidth = 1 / viewState.scale;

                layer.planes.forEach(plane => {
                    drawPlane(plane);
                });
            });

            // Draw saved cuts
            if (cutMode.enabled) {
                drawSavedCuts();
                // Draw current cut being drawn
                if (cutMode.isDrawing && cutMode.currentCut.length > 0) {
                    drawCurrentCut();
                }
            }
        }

        // Draw grid
        function drawGrid() {
            const gridSize = 0.01; // 10mm in meters
            const screenGridSize = gridSize * viewState.scale;

            if (screenGridSize < 10) return; // Don't draw if too small

            ctx.strokeStyle = '#3e3e42';
            ctx.lineWidth = 1;

            // Vertical lines
            const startX = Math.floor((-viewState.offsetX / viewState.scale) / gridSize) * gridSize;
            for (let x = startX; x * viewState.scale + viewState.offsetX < canvas.width; x += gridSize) {
                const screenX = worldToScreen(x, 0).x;
                ctx.beginPath();
                ctx.moveTo(screenX, 0);
                ctx.lineTo(screenX, canvas.height);
                ctx.stroke();
            }

            // Horizontal lines
            const startY = Math.floor((-viewState.offsetY / viewState.scale) / gridSize) * gridSize;
            for (let y = startY; y * viewState.scale + viewState.offsetY < canvas.height; y += gridSize) {
                const screenY = worldToScreen(0, y).y;
                ctx.beginPath();
                ctx.moveTo(0, screenY);
                ctx.lineTo(canvas.width, screenY);
                ctx.stroke();
            }
        }

        // Draw single plane
        function drawPlane(plane) {
            if (!plane.points || plane.points.length < 3) return;

            ctx.beginPath();
            const firstPoint = worldToScreen(plane.points[0][0], plane.points[0][1]);
            ctx.moveTo(firstPoint.x, firstPoint.y);

            for (let i = 1; i < plane.points.length; i++) {
                const point = worldToScreen(plane.points[i][0], plane.points[i][1]);
                ctx.lineTo(point.x, point.y);
            }

            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        // Zoom functions
        function zoomIn() {
            viewState.scale *= 1.2;
            updateZoomLabel();
            render();
        }

        function zoomOut() {
            viewState.scale /= 1.2;
            updateZoomLabel();
            render();
        }

        function updateZoomLabel() {
            const zoomPercent = Math.round(viewState.scale * 100 / 100);
            document.getElementById('zoomLevel').textContent = zoomPercent + '%';
        }

        // ========== Cut Mode Functions ==========

        function toggleCutMode() {
            cutMode.enabled = !cutMode.enabled;
            const btn = document.getElementById('cutModeBtn');
            const cutTools = document.getElementById('cutTools');
            const cutList = document.getElementById('cutList');

            if (cutMode.enabled) {
                btn.classList.add('active');
                cutTools.classList.remove('hidden');
                cutList.classList.remove('hidden');
                canvas.classList.add('cut-mode');
                refreshCutList();
                document.getElementById('statusText').textContent = 'Cut Mode Active - Select a tool to start cutting';
            } else {
                btn.classList.remove('active');
                cutTools.classList.add('hidden');
                cutList.classList.add('hidden');
                canvas.classList.remove('cut-mode');
                cutMode.activeTool = null;
                cutMode.currentCut = [];
                cutMode.isDrawing = false;
                cutMode.panMode = false;
                document.querySelectorAll('.cut-tool-btn').forEach(b => b.classList.remove('active'));
                document.getElementById('finishCutBtn').classList.add('hidden');
                document.getElementById('statusText').textContent = 'Cut Mode Disabled';
                canvas.style.cursor = 'grab';
            }

            render();
        }

        function selectCutTool(tool) {
            if (!cutMode.enabled) return;

            // Reset current drawing
            cutMode.currentCut = [];
            cutMode.isDrawing = false;

            // Set active tool
            cutMode.activeTool = tool;

            // Update UI
            document.querySelectorAll('.cut-tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');

            // Update hint
            const hints = {
                'line': 'Click two points to draw a line',
                'rectangle': 'Click two opposite corners to draw a rectangle',
                'polyline': 'Click points, then click "Finish & Save Cut" or right-click'
            };
            document.getElementById('cutHint').textContent = hints[tool];
            document.getElementById('statusText').textContent = `${tool.toUpperCase()} tool selected - ${hints[tool]}`;

            // Show finish button for polyline
            document.getElementById('finishCutBtn').classList.add('hidden');

            render();
        }

        function togglePanMode() {
            if (!cutMode.enabled) return;

            cutMode.panMode = !cutMode.panMode;
            const panBtn = document.getElementById('panModeBtn');

            if (cutMode.panMode) {
                panBtn.style.background = '#10a37f';
                panBtn.textContent = '‚úã Pan Active (Space)';
                canvas.style.cursor = 'grab';
                document.getElementById('statusText').textContent = 'Pan Mode - Click and drag to move view';
            } else {
                panBtn.style.background = '#3e3e42';
                panBtn.textContent = 'ü§ö Pan Mode (Space)';
                canvas.style.cursor = 'crosshair';
                document.getElementById('statusText').textContent = 'Cut Mode - Select a tool to continue';
            }
        }

        function finishCurrentCut() {
            if (cutMode.currentCut.length >= 2) {
                cutMode.isDrawing = false;
                saveCut();
                document.getElementById('finishCutBtn').classList.add('hidden');
            } else {
                alert('Need at least 2 points to save a cut');
            }
        }

        function drawSavedCuts() {
            cutMode.savedCuts.forEach(cut => {
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);

                if (cut.points && cut.points.length > 0) {
                    ctx.beginPath();
                    const first = worldToScreen(cut.points[0][0], cut.points[0][1]);
                    ctx.moveTo(first.x, first.y);

                    for (let i = 1; i < cut.points.length; i++) {
                        const pt = worldToScreen(cut.points[i][0], cut.points[i][1]);
                        ctx.lineTo(pt.x, pt.y);
                    }

                    if (cut.type === 'rectangle') {
                        ctx.closePath();
                    }

                    ctx.stroke();
                }

                ctx.setLineDash([]);
            });
        }

        function drawCurrentCut() {
            if (cutMode.currentCut.length === 0) return;

            ctx.strokeStyle = '#ff3333';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);

            ctx.beginPath();
            const first = worldToScreen(cutMode.currentCut[0][0], cutMode.currentCut[0][1]);
            ctx.moveTo(first.x, first.y);

            for (let i = 1; i < cutMode.currentCut.length; i++) {
                const pt = worldToScreen(cutMode.currentCut[i][0], cutMode.currentCut[i][1]);
                ctx.lineTo(pt.x, pt.y);
            }

            if (cutMode.activeTool === 'rectangle' && cutMode.currentCut.length === 2) {
                // Complete rectangle
                const pt1 = worldToScreen(cutMode.currentCut[0][0], cutMode.currentCut[0][1]);
                const pt2 = worldToScreen(cutMode.currentCut[1][0], cutMode.currentCut[1][1]);
                ctx.clearRect(0, 0, 0, 0);
                ctx.beginPath();
                ctx.rect(pt1.x, pt1.y, pt2.x - pt1.x, pt2.y - pt1.y);
            }

            ctx.stroke();
            ctx.setLineDash([]);
        }

        async function saveCut() {
            if (cutMode.currentCut.length === 0) {
                alert('No cut to save');
                return;
            }

            const cutData = {
                type: cutMode.activeTool,
                points: cutMode.currentCut
            };

            try {
                const result = await window.pywebview.api.save_cut_data(cutData);
                if (result.success) {
                    console.log('Cut saved:', result.id);
                    cutMode.currentCut = [];
                    cutMode.isDrawing = false;
                    await refreshCutList();
                    render();
                    document.getElementById('statusText').textContent = `Cut saved: ${result.id}`;
                } else {
                    alert('Error saving cut: ' + result.error);
                }
            } catch (error) {
                console.error('Error saving cut:', error);
                alert('Error saving cut: ' + error.message);
            }
        }

        async function refreshCutList() {
            try {
                const cuts = await window.pywebview.api.get_cut_list();
                cutMode.savedCuts = [];

                // Load full cut data for rendering
                for (const cut of cuts) {
                    const fullData = await window.pywebview.api.get_cut_data(cut.id);
                    if (fullData) {
                        cutMode.savedCuts.push(fullData);
                    }
                }

                const cutListItems = document.getElementById('cutListItems');
                const cutCount = document.getElementById('cutCount');
                cutCount.textContent = cuts.length;

                if (cuts.length === 0) {
                    cutListItems.innerHTML = '<div style="color: #858585; font-size: 11px; text-align: center;">No cuts saved</div>';
                } else {
                    cutListItems.innerHTML = cuts.map(cut => `
                        <div class="cut-list-item">
                            <div>
                                <div style="color: #9cdcfe;">${cut.id}</div>
                                <div style="color: #858585; font-size: 10px;">${cut.type}</div>
                            </div>
                            <button class="cut-delete-btn" onclick="deleteCut('${cut.id}')">Delete</button>
                        </div>
                    `).join('');
                }

                render();
            } catch (error) {
                console.error('Error refreshing cut list:', error);
            }
        }

        async function deleteCut(cutId) {
            try {
                const result = await window.pywebview.api.delete_cut(cutId);
                if (result.success) {
                    await refreshCutList();
                    document.getElementById('statusText').textContent = `Deleted: ${cutId}`;
                } else {
                    alert('Error deleting cut: ' + result.error);
                }
            } catch (error) {
                console.error('Error deleting cut:', error);
                alert('Error deleting cut: ' + error.message);
            }
        }

        async function clearAllCuts() {
            if (!confirm('Delete all cuts?')) return;

            try {
                const cuts = await window.pywebview.api.get_cut_list();
                for (const cut of cuts) {
                    await window.pywebview.api.delete_cut(cut.id);
                }
                await refreshCutList();
                document.getElementById('statusText').textContent = 'All cuts deleted';
            } catch (error) {
                console.error('Error clearing cuts:', error);
                alert('Error clearing cuts: ' + error.message);
            }
        }

        // ========== Cut Drawing Handlers ==========

        function handleCutMouseDown(e) {
            const worldPos = screenToWorld(e.offsetX, e.offsetY);

            switch (cutMode.activeTool) {
                case 'line':
                    if (!cutMode.isDrawing) {
                        // Start line
                        cutMode.isDrawing = true;
                        cutMode.currentCut = [[worldPos.x, worldPos.y]];
                        document.getElementById('statusText').textContent = 'Click end point';
                    } else {
                        // Finish line
                        cutMode.currentCut.push([worldPos.x, worldPos.y]);
                        cutMode.isDrawing = false;
                        saveCut();
                    }
                    break;

                case 'rectangle':
                    if (!cutMode.isDrawing) {
                        // Start rectangle - first corner
                        cutMode.isDrawing = true;
                        cutMode.currentCut = [[worldPos.x, worldPos.y]];
                        document.getElementById('statusText').textContent = 'Click opposite corner';
                    } else {
                        // Finish rectangle - second corner
                        const [x1, y1] = cutMode.currentCut[0];
                        cutMode.currentCut = [
                            [x1, y1],
                            [worldPos.x, y1],
                            [worldPos.x, worldPos.y],
                            [x1, worldPos.y]
                        ];
                        cutMode.isDrawing = false;
                        saveCut();
                    }
                    break;

                case 'polyline':
                    if (!cutMode.isDrawing) {
                        cutMode.isDrawing = true;
                        cutMode.currentCut = [[worldPos.x, worldPos.y]];
                        document.getElementById('finishCutBtn').classList.remove('hidden');
                        document.getElementById('statusText').textContent = 'Click points, then click "Finish & Save Cut" or right-click';
                    } else {
                        cutMode.currentCut.push([worldPos.x, worldPos.y]);
                        document.getElementById('statusText').textContent = `${cutMode.currentCut.length} points - Click to add more`;
                    }
                    render();
                    break;
            }

            render();
        }

        function handleCutMouseMove(e) {
            const worldPos = screenToWorld(e.offsetX, e.offsetY);

            switch (cutMode.activeTool) {
                case 'line':
                    if (cutMode.isDrawing && cutMode.currentCut.length === 1) {
                        // Show preview of line
                        cutMode.currentCut[1] = [worldPos.x, worldPos.y];
                        render();
                    }
                    break;

                case 'rectangle':
                    if (cutMode.isDrawing && cutMode.currentCut.length === 1) {
                        // Show preview rectangle
                        const [x1, y1] = cutMode.currentCut[0];
                        const tempRect = [
                            [x1, y1],
                            [worldPos.x, y1],
                            [worldPos.x, worldPos.y],
                            [x1, worldPos.y]
                        ];

                        // Draw preview
                        render();
                        ctx.strokeStyle = '#ff3333';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        const pt1 = worldToScreen(tempRect[0][0], tempRect[0][1]);
                        ctx.moveTo(pt1.x, pt1.y);
                        for (let i = 1; i < tempRect.length; i++) {
                            const pt = worldToScreen(tempRect[i][0], tempRect[i][1]);
                            ctx.lineTo(pt.x, pt.y);
                        }
                        ctx.closePath();
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                    break;

                case 'polyline':
                    // Show preview line to cursor
                    render();
                    if (cutMode.isDrawing && cutMode.currentCut.length > 0) {
                        const last = cutMode.currentCut[cutMode.currentCut.length - 1];
                        const lastScreen = worldToScreen(last[0], last[1]);

                        ctx.strokeStyle = '#ff3333';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([3, 3]);
                        ctx.beginPath();
                        ctx.moveTo(lastScreen.x, lastScreen.y);
                        ctx.lineTo(e.offsetX, e.offsetY);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                    break;
            }
        }

        function handleCutMouseUp(e) {
            // No longer needed for rectangle since it's now click-based
        }

        // Mouse event handlers
        canvas.addEventListener('mousedown', (e) => {
            if (cutMode.enabled && cutMode.panMode) {
                // Pan mode in cut mode
                viewState.isDragging = true;
                viewState.lastX = e.clientX;
                viewState.lastY = e.clientY;
            } else if (cutMode.enabled && cutMode.activeTool) {
                handleCutMouseDown(e);
            } else {
                viewState.isDragging = true;
                viewState.lastX = e.clientX;
                viewState.lastY = e.clientY;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            // Update mouse position display
            const worldPos = screenToWorld(e.offsetX, e.offsetY);
            document.getElementById('mousePos').textContent =
                `X: ${worldPos.x.toFixed(6)}, Y: ${worldPos.y.toFixed(6)}`;

            // Handle cut mode drawing
            if (cutMode.enabled && cutMode.isDrawing) {
                handleCutMouseMove(e);
            }
            // Handle dragging
            else if (viewState.isDragging) {
                const dx = e.clientX - viewState.lastX;
                const dy = e.clientY - viewState.lastY;

                viewState.offsetX += dx;
                viewState.offsetY += dy;

                viewState.lastX = e.clientX;
                viewState.lastY = e.clientY;

                render();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (cutMode.enabled && cutMode.isDrawing) {
                handleCutMouseUp(e);
            } else {
                viewState.isDragging = false;
            }
        });

        canvas.addEventListener('mouseleave', () => {
            viewState.isDragging = false;
        });

        // Right-click to finish polyline
        canvas.addEventListener('contextmenu', (e) => {
            if (cutMode.enabled && cutMode.activeTool === 'polyline' && cutMode.isDrawing && cutMode.currentCut.length >= 2) {
                e.preventDefault();
                finishCurrentCut();
            } else if (cutMode.enabled) {
                e.preventDefault(); // Prevent context menu in cut mode
            }
        });

        // Keyboard shortcuts for Cut Mode
        document.addEventListener('keydown', (e) => {
            if (!cutMode.enabled) return;

            if (e.key === 'Escape') {
                // Cancel current cut
                cutMode.currentCut = [];
                cutMode.isDrawing = false;
                document.getElementById('finishCutBtn').classList.add('hidden');
                render();
                document.getElementById('statusText').textContent = 'Cut cancelled';
            } else if (e.key === ' ') {
                // Toggle pan mode with Space
                e.preventDefault();
                togglePanMode();
            }
        });

        // Zoom with mouse wheel
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();

            const mouseX = e.offsetX;
            const mouseY = e.offsetY;

            const worldBefore = screenToWorld(mouseX, mouseY);

            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            viewState.scale *= zoomFactor;

            const worldAfter = screenToWorld(mouseX, mouseY);

            viewState.offsetX += (worldAfter.x - worldBefore.x) * viewState.scale;
            viewState.offsetY += (worldAfter.y - worldBefore.y) * viewState.scale;

            updateZoomLabel();
            render();
        });

        // Window resize handler
        window.addEventListener('resize', resizeCanvas);

        // Initialize when pywebview is ready
        window.addEventListener('pywebviewready', function() {
            console.log('PyWebView ready!');
            resizeCanvas();
            // Auto-load data on startup
            setTimeout(reloadData, 500);
        });

        // Initialize canvas
        resizeCanvas();
    </script>
</body>
</html>
